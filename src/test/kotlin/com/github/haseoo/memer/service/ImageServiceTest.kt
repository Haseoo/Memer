package com.github.haseoo.memer.service

import com.github.haseoo.memer.config.Env
import com.github.haseoo.memer.domain.exception.LinkExpiredException
import com.github.haseoo.memer.domain.images.ImageTokenResponse
import com.github.haseoo.memer.domain.images.ImagesAuthData
import com.github.haseoo.memer.repository.ImagesAuthDataRepository
import io.mockk.every
import io.mockk.impl.annotations.InjectMockKs
import io.mockk.impl.annotations.MockK
import io.mockk.junit5.MockKExtension
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.assertThatThrownBy
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.springframework.http.HttpEntity
import org.springframework.web.client.RestTemplate
import java.security.SecureRandom
import java.util.*


@ExtendWith(MockKExtension::class)
internal class ImageServiceTest {

    @MockK
    private lateinit var _restTemplate: RestTemplate

    @MockK
    private lateinit var _secureRandom: SecureRandom

    @MockK
    private lateinit var _imagesAuthDataRepository: ImagesAuthDataRepository

    @MockK
    private lateinit var _env: Env

    @InjectMockKs
    private lateinit var sut: ImageService

    @Test
    fun `generateImageLink should save auth data with key that was generated by secure random and returns link with url encoded key`() {
        //given
        val domain = "example.com"
        val supposedlyRandomBytes = "testing".toByteArray().copyOf(64)
        val expectedKey = Base64.getUrlEncoder().encodeToString(supposedlyRandomBytes)
        val serverId = 2137L
        val serverName = "test"
        val channelIds = listOf(21L, 37L)
        val authData = ImagesAuthData(serverId, serverName, channelIds)
        every { _secureRandom.nextBytes(any()) } answers { supposedlyRandomBytes.copyInto(firstArg()) }
        every { _imagesAuthDataRepository.saveAuthData(expectedKey, authData) } returns Unit
        every { _env.memerUrl } returns domain
        //when
        val result = sut.generateImageLink(serverId, serverName, channelIds)
        //then
        assertThat(result)
            .contains(domain)
            .contains(expectedKey)
    }

    @Test
    fun `generateImageToken should throw LinkExpiredException when token is not present in the storage`() {
        //given
        val key = "does not exist"
        every { _imagesAuthDataRepository.popAuthData(key) } returns null
        //when & then
        assertThatThrownBy { sut.generateImageToken(key) }
            .isInstanceOf(LinkExpiredException::class.java)
    }

    @Test
    fun `generateImageToken should throw IllegalStateException with cause from image storage service communication`() {
        //given
        val key = "that's a secret!"
        val imagesAuthDataJson = """{"serverId":2137,"serverName":"test","channelIds":[1,2,3]}"""
        val exception = Exception("I'm so expected!")
        val domain = "example.com"
        val expectedEndpoint = "$domain/api/token"
        every { _env.dscViewerUrl } returns domain
        every { _imagesAuthDataRepository.popAuthData(key) } returns imagesAuthDataJson
        every {
            _restTemplate.postForObject(
                expectedEndpoint,
                match<HttpEntity<String>> { it.body == imagesAuthDataJson },
                ImageTokenResponse::class.java
            )
        } throws exception
        //when & then
        assertThatThrownBy { sut.generateImageToken(key) }
            .isInstanceOf(IllegalStateException::class.java)
            .hasCause(exception)
    }


    @Test
    fun `generateImageToken should return token generated by image storage service`() {
        //given
        val key = "that's a secret!"
        val imagesAuthDataJson = """{"serverId":2137,"serverName":"test","channelIds":[1,2,3]}"""
        val domain = "example.com"
        val expectedEndpoint = "$domain/api/token"
        val expectedToken = "IMA TOKEN OUT"
        val response = ImageTokenResponse(expectedToken)
        every { _env.dscViewerUrl } returns domain
        every { _imagesAuthDataRepository.popAuthData(key) } returns imagesAuthDataJson
        every {
            _restTemplate.postForObject(
                expectedEndpoint,
                match<HttpEntity<String>> { it.body == imagesAuthDataJson },
                ImageTokenResponse::class.java
            )
        } returns response
        //when
        val result = sut.generateImageToken(key)
        //then
        assertThat(result).isEqualTo(expectedToken)
    }
}